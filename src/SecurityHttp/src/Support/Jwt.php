<?php

declare(strict_types=1);
/**
 * This file is part of MineAdmin.
 *
 * @link     https://www.mineadmin.com
 * @document https://doc.mineadmin.com
 * @contact  root@imoi.cn
 * @license  https://github.com/mineadmin/MineAdmin/blob/master/LICENSE
 */

namespace Mine\Security\Http\Support;

use Carbon\Carbon;
use Lcobucci\JWT\Configuration;
use Lcobucci\JWT\Signer;
use Lcobucci\JWT\Signer\Key;
use Lcobucci\JWT\Signer\Key\InMemory;
use Lcobucci\JWT\Token;
use Lcobucci\JWT\Token\RegisteredClaims;
use Lcobucci\JWT\UnencryptedToken;
use Lcobucci\JWT\Validation\Constraint\IdentifiedBy;
use Lcobucci\JWT\Validation\Constraint\SignedWith;
use Mine\Security\Http\Constant\TokenValidConstant;
use Mine\Security\Http\Contract\BlackContract;
use Mine\Security\Http\Exception\JwtConfigException;
use Mine\Security\Http\Exception\TokenValidException;
use Mine\Security\Http\TokenObject;
use Mine\SecurityBundle\Config;
use Psr\Container\ContainerInterface;

class Jwt
{
    public function __construct(
        private readonly Config $config,
        private readonly ContainerInterface $container
    ) {}

    /**
     * @throws JwtConfigException
     */
    public function generator(TokenObject $tokenObject, string $scene = 'default'): UnencryptedToken
    {
        $config = $this->getSceneConfig($scene);
        $loginType = $config['login_type'];
        $ssoKey = $config['sso_key'];
        $claims = $tokenObject->getClaims();
        $headers = $tokenObject->getHeaders();
        if ($loginType === 'mpop') { // Multi-login, scenario values with a unique id
            $unique = uniqid($scene . '_', true);
        } else { // 单点登录
            if (empty($claims[$ssoKey])) {
                throw new JwtConfigException("There is no {$ssoKey} key in the claims", 400);
            }
            // unique
            $unique = $scene . '_' . $claims[$ssoKey];
        }

        $signer = $this->getSigner($config);
        $time = Carbon::now()->addSeconds($this->getTtl($config));
        $datetimeImmutable = $time->toDateTimeImmutable();
        $builder = $this->getConfiguration($signer, $this->getKey($config))->builder();
        $builder = $builder
            ->issuedBy($tokenObject->getIssuedBy())
            ->identifiedBy($unique)
            ->issuedAt($datetimeImmutable)
            ->canOnlyBeUsedAfter($datetimeImmutable)
            ->expiresAt($datetimeImmutable);

        $claims['scene'] = $scene; // Add scene values
        foreach ($claims as $k => $v) {
            $builder = $builder->withClaim($k, $v); // Customized data
        }
        foreach ($headers as $k => $v) {
            $builder = $builder->withHeader($k, $v); // Customized data
        }

        $token = $builder->getToken($signer, $this->getKey($config)); // Retrieves the generated token

        // Single sign-on to invalidate all previously generated tokens
        if ($loginType === 'sso' && $tokenObject->isInsertSsoBlack) {
            $this->getBlack($config)->add($token, $config);
        }

        return $token;
    }

    public function getTtl(array $config): int
    {
        return (int) $config['ttl'];
    }

    /**
     * @throws JwtConfigException
     */
    public function parse(string $token, string $scene = 'default', bool $validate = true): Token
    {
        $config = $this->getSceneConfig($scene);
        $signer = new $config['supported_algs'][$config['alg']]();
        $parser = $this->getConfiguration($signer, $this->getKey($config))->parser();
        $resolveToken = $parser->parse($token);
        $claims = $resolveToken->claims()->all();
        $tokenScene = $claims['scene'];
        // Get the scenario configuration for the current environment and verify that the token is generated by that configuration.
        if ($tokenScene !== $scene && $this->getIndependentTokenVerify($config)) {
            throw new TokenValidException('Token authentication does not pass', 401);
        }
        // Judging from the configuration information, set the scene. scene corresponding to the current token
        if (! $this->getIndependentTokenVerify($config)) {
            $scene = $tokenScene ?? $scene;
        }
        $config = $this->getSceneConfig($scene);
        $signer = new $config['supported_algs'][$config['alg']]();

        // Verify that the token is blacklisted
        if ($config['blacklist_enabled'] && $this->getBlack($config)->has($claims, $config)) {
            throw new TokenValidException(TokenValidConstant::IN_BLACKLIST, 'Token authentication does not pass');
        }

        if ($validate && ! $this->getValidationData($signer, $this->getKey($config), $token)) {
            throw new TokenValidException(TokenValidConstant::PARSER_DATA_VALID, 'Token authentication does not pass');
        }
        return $resolveToken;
    }

    /**
     * Refresh token.
     * @throws JwtConfigException
     */
    public function refreshToken(string $token, string $scene = 'default'): Token
    {
        $oldToken = $this->parse($token, $scene);
        $claims = $oldToken->claims()->all();
        $headers = $oldToken->headers()->all();
        unset(
            $claims['iat'],
            $claims['nbf'],
            $claims['exp'],
            $claims['jti'],
            $claims['iss'],
        );
        $tokenInstance = new TokenObject();
        $tokenInstance->setHeaders($headers);
        $tokenInstance->setClaims($claims);
        return $this->generator($tokenInstance, $scene);
    }

    /**
     * Invalidate the token.
     * @throws JwtConfigException
     */
    public function logout(string $token, string $scene = 'default'): bool
    {
        $config = $this->getSceneConfig($scene);
        return $this->getBlack($config)->add($this->parse($token), $config);
    }

    /**
     * Get token dynamic validity time.
     */
    public function getTokenDynamicCacheTime(string $token): int
    {
        $claims = $this->parse($token)->claims();
        /**
         * @var null|\DateTimeImmutable $exp
         */
        if ($exp = $claims->get(RegisteredClaims::EXPIRATION_TIME)) {
            return Carbon::now()->diffInSeconds($exp);
        }
        return -1;
    }

    public function getIndependentTokenVerify(array $config): bool
    {
        return $config['independentTokenVerify'] ?? false;
    }

    public function getValidationData(Signer $signer, Key $key, string $token): bool
    {
        $config = $this->getConfiguration($signer, $key);
        $parser = $config->parser()->parse($token);
        $claims = $parser->claims()->all();

        $config->setValidationConstraints(new IdentifiedBy($claims['jti']));
        $config->setValidationConstraints(new SignedWith($signer, $key));

        if (! $config->validator()->validate($parser, ...$config->validationConstraints())) {
            return false;
        }

        return true;
    }

    public function getConfiguration(Signer $signer, Key $key): Configuration
    {
        return Configuration::forSymmetricSigner($signer, $key);
    }

    public function getBlack(array $config): BlackContract
    {
        if (empty($config['black']) || class_exists($config['black']) === false) {
            throw new JwtConfigException(sprintf('jwt config black is empty'));
        }
        return $this->container->get($config['black']);
    }

    public function getSceneConfig(string $scene): array
    {
        $config = $this->config->get('jwt', []);
        $isDefault = $scene === 'default';
        if (empty($config)) {
            throw new JwtConfigException(sprintf('jwt config is empty'));
        }
        if (! $isDefault && ! isset($config['scene'][$scene])) {
            throw new JwtConfigException(sprintf('jwt config scene is empty. %s', $scene));
        }
        $sceneConfig = $isDefault ? $config : $config['scene'][$scene];
        if (! $isDefault) {
            // If it is not the default scenario, the default configuration is merged in
            $keys = [
                'login_type', 'sso_key', 'secret', 'keys',
                'ttl', 'alg', 'supported_algs', 'symmetry_algs',
                'asymmetric_algs', 'blacklist_enabled', 'blacklist_grace_period',
                'blacklist_cache_ttl', 'blacklist_prefix', 'black',
            ];
            foreach ($keys as $key) {
                if (empty($sceneConfig[$key])) {
                    $sceneConfig[$key] = $config[$key];
                }
            }
        }
        return $sceneConfig;
    }

    /**
     * Get the key needed by the corresponding algorithm.
     */
    public function getKey(array $config, string $type = 'private'): ?Key
    {
        $key = null;
        // symmetry algorithm
        if (in_array($config['alg'], $config['symmetry_algs'], true)) {
            $key = InMemory::base64Encoded($config['secret']);
        }

        // asymmetric
        if (in_array($config['alg'], $config['asymmetric_algs'], true)) {
            $key = InMemory::base64Encoded($config['keys'][$type]);
        }
        return $key;
    }

    public function getSigner(array $config): Signer
    {
        return new $config['supported_algs'][$config['alg']]();
    }
}
